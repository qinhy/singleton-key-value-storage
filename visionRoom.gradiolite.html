<!doctype html>
<html>
	<head>
		<script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/@gradio/lite/dist/lite.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@gradio/lite/dist/lite.css" />
	</head>
	<body>
		<gradio-lite>
      import base64
      from datetime import datetime
      import io
      import json
      import os
      from typing import Any, List, Dict
      import re
      import fnmatch
      from uuid import uuid4
      from pydantic import BaseModel, ConfigDict, Field
      import requests
      from PIL import Image
      
      class SingletonStorageController:
      
        def add_slave(self, slave):
            self.model.slaves.append(slave)
            
        def _set_slaves(self, key: str, value: dict):
            [s.set(key, value) for s in self.model.slaves if hasattr(s, 'set')]
      
        def _delete_slaves(self, key: str):
            [s.delete(key) for s in self.model.slaves if hasattr(s, 'delete')]
      
        def exists(self, key: str): print('not implement')
      
        def set(self, key: str, value: dict): print('not implement')
      
        def get(self, key: str) -> dict: print('not implement')
      
        def delete(self, key: str): print('not implement')
      
        def keys(self, pattern: str): print('not implement')
      
        def dump(self, json_path=None): print('not implement')
      
        def load(self, json_path=None): print('not implement')
      
        def dumps(self): print('not implement')
      
        def loads(self, json_string=None): print('not implement')
      
      class SingletonPythonDictStorage:
        _instance = None
        _meta = {}
      
        def __new__(cls):
            if cls._instance is None:
                cls._instance = super(SingletonPythonDictStorage, cls).__new__(cls)
                cls._instance.store = {}
                cls._instance.slaves = []
            return cls._instance
      
        def __init__(self):
            self.slaves:list = self.slaves
            self.store:dict = self.store
      
      class SingletonPythonDictStorageController(SingletonStorageController):
        def __init__(self, model:SingletonPythonDictStorage):
            self.model = model
      
        def exists(self, key: str):
            return key in self.model.store
      
        def set(self, key: str, value: dict):
            self.model.store[key] = value
            self._set_slaves(key,value)
      
        def get(self, key: str) -> dict:
            return self.model.store[key]
      
        def delete(self, key: str):
            if key in self.model.store:
                del self.model.store[key]
            self._delete_slaves(key)
      
        def keys(self, pattern: str):
            return fnmatch.filter(self.model.store.keys(), pattern)
      
        def dumps(self):
            return json.dumps(self.model.store)
        
        def loads(self, json_string=None):
           self.model.store = json.loads(json_string)
      
        def dump(self,path="PythonDictStorage.json"):
            with open(path, "w") as tf: json.dump(self.model.store, tf)
      
        def load(self,path="PythonDictStorage.json"):
            with open(path, "r") as tf: self.model.store = json.load(tf)
      
      class SingletonKeyValueStorage(SingletonStorageController):
        def __init__(self) -> None:
            self.python_backend()
        
        def python_backend(self):
            self.client = SingletonPythonDictStorageController(SingletonPythonDictStorage())
            return self
      
        def exists(self, key: str): return self.client.exists(key)
      
        def set(self, key: str, value: dict): self.client.set( key, value)
      
        def get(self, key: str) -> dict: return self.client.get( key)
      
        def delete(self, key: str): self.client.delete(key)
      
        def keys(self, pattern: str): return self.client.keys(pattern)
      
        def dump(self,json_path): self.client.dump(json_path)
      
        def load(self,json_path): self.client.load(json_path)
      
      def get_current_datetime_with_utc():
        return datetime.now()
      
      class AbstractObjController:
        def __init__(self, store, model):
            self.model:AbstractObj = model
            self._store:LLMstore = store
      
        def update(self, **kwargs):
            assert  self.model is not None, 'controller has null model!'
            for key, value in kwargs.items():
                if hasattr(self.model, key):
                    setattr(self.model, key, value)
            self._update_timestamp()
            self.store()
      
        def _update_timestamp(self):
            assert  self.model is not None, 'controller has null model!'
            self.model.update_time = get_current_datetime_with_utc()
            
        def store(self):
            self._store._store_obj(self.model)
            return self
      
        def delete(self):
            self._store.delete_obj(self.model)
      
        def update_metadata(self, key, value):
            updated_metadata = {**self.model.metadata, key: value}
            self.update(metadata = updated_metadata)
            return self
      
      class CommonDataController(AbstractObjController):
        def __init__(self, store, model):
            self.model: CommonData = model
            self._store:LLMstore = store
      
      class AuthorController(AbstractObjController):
        def __init__(self, store ,model):
            self.model: Author = model
            self._store:LLMstore = store
      
      class AbstractContentController(AbstractObjController):
        def __init__(self, store, model):
            self.model: AbstractContent = model
            self._store:LLMstore = store
      
        def data_id(self):
            return f"CommonData:{self.model.id}"
      
        def delete(self):
            self.get_data().controller.delete()        
            self._store.delete_obj(self.model)
      
        def get_author(self):
            author:Author = self._store.find(self.model.author_id)
            return author
      
        def get_group(self):
            res:ContentGroup = self._store.find(self.model.group_id)
            return res
        
        def get_data(self):
            res:CommonData = self._store.find(self.data_id())
            return res
      
        def get_data_raw(self):
            return self.get_data().raw    
      
        def update_data_raw(self, msg: str):
            self.get_data().controller.update(raw = msg)
            return self
      
        def append_data_raw(self, msg: str):
            data = self.get_data()
            data.controller.update(raw = data.raw + msg)
            return self
        
      class AbstractGroupController(AbstractObjController):
        def __init__(self, store, model):
            self.model:AbstractGroup = model
            self._store:LLMstore = store
      
        def yield_children_content_recursive(self, depth: int = 0):
            for child_id in self.model.children_id:
                if not self._store.exists(child_id):
                    continue
                content:AbstractObj = self._store.find(child_id)
                yield content, depth
                if child_id.startswith('ContentGroup'):
                    group:AbstractGroupController = content.controller
                    for cc, d in group.yield_children_content_recursive(depth + 1):
                        yield cc, d
      
        def delete_recursive_from_keyValue_storage(self):
            for c, d in self.yield_children_content_recursive():
                c.controller.delete()
            self.delete()
      
        def get_children_content(self):
            # self.load()
            assert  self.model is not None, 'controller has null model!'
            results:List[AbstractObj] = []
            for child_id in self.model.children_id:
                results.append(self._store.find(child_id))
            return results
      
        def get_child_content(self, child_id: str):
            res:AbstractContent = self._store.find(child_id)
            return res
      
        def prints(self):
            print('########################################################')
            for content, depth in self.yield_children_content_recursive():
                print(f"{'    ' * depth}{content.id}")
            print('########################################################')
      
      class ContentGroupController(AbstractGroupController):
        def __init__(self, store, model):
            self.model:ContentGroup = model
            self._store:LLMstore = store
      
        def add_new_child_group(self,metadata={},rank=[0]):
            parent,child = self._store.add_new_group_to_group(group=self.model,metadata=metadata,rank=rank)
            return child
      
        def add_new_text_content(self, author_id:str, text:str):
            parent,child = self._store.add_new_text_to_group(group=self.model,author_id=author_id,
                                                     text=text)                             
            return child
        
        def add_new_embeding_content(self, author_id:str, content_id:str, vec:list[float]):
            parent,child = self._store.add_new_embedding_to_group(group=self.model,author_id=author_id,
                                                           content_id=content_id, vec=vec)                                   
            return child
        
        def add_new_image_content(self,author_id:str, filepath:str):
            parent,child = self._store.add_new_image_to_group(group=self.model,author_id=author_id,
                                                      filepath=filepath)                              
            return child
            
      
        def remove_child(self, child_id:str):
            remaining_ids = [cid for cid in self.model.children_id if cid != child_id]
            for content in self.get_children_content():
                if content.controller.model.id == child_id:
                    if child_id.startswith('ContentGroup'):
                        group:ContentGroupController = content.controller
                        group.delete_recursive_from_keyValue_storage()
                    content.controller.delete()
                    break
            self.update(children_id = remaining_ids)
            return self
      
        def get_children_content_recursive(self):
            results:list[AbstractContent] = []
            for c, d in self.yield_children_content_recursive():
                results.append(c)
            return results
      
      class TextContentController(AbstractContentController):
        def __init__(self, store, model):
            self.model:TextContent = model
            self._store:LLMstore = store
      
      
      class EmbeddingContentController(AbstractContentController):
        def __init__(self, store, model):
            self.model: EmbeddingContent = model
            self._store:LLMstore = store
      
        def get_data_raw(self):
            return list(map(float,super().get_data_raw()[1:-1].split(',')))
        
        def get_data_rLOD0(self):
            return self.get_data_raw()[::10**(0+1)]
        
        def get_data_rLOD1(self):
            return self.get_data_raw()[::10**(1+1)]
        
        def get_data_rLOD2(self):
            return self.get_data_raw()[::10**(2+1)]
        
        def get_target(self):
            assert  self.model is not None, 'controller has null model!'
            target_id = self.model.target_id
            res:AbstractContent = self._store.find(target_id)
            return res
        
        def update_data_raw(self, embedding: list[float]):
            super().update_data_raw(str(embedding))
            return self
      
      class FileLinkContentController(AbstractContentController):
        def __init__(self, store, model):
            self.model: FileLinkContent = model
            self._store:LLMstore = store
      
      class BinaryFileContentController(AbstractContentController):
        def __init__(self, store, model):
            self.model: BinaryFileContent = model
            self._store:LLMstore = store
            
        def read_bytes(self, filepath):
            with open(filepath, "rb") as f:
                return f.read()
            
        def b64decode(self, file_base64):
            return base64.b64decode(file_base64)
            
        def get_data_rLOD0(self):
            raise ValueError('binary file has no LOD concept')
        
        def get_data_rLOD1(self):
            raise ValueError('binary file has no LOD concept')
        
        def get_data_rLOD2(self):
            raise ValueError('binary file has no LOD concept')
        
      class ImageContentController(BinaryFileContentController):
        def __init__(self, store, model):
            self.model: ImageContent = model    
            self._store:LLMstore = store
      
        def decode_image(self, encoded_string):
            return Image.open(io.BytesIO(self.b64decode(encoded_string)))
        
        def get_image(self):
            encoded_image = self.get_data_raw()
            if encoded_image:
                image = self.decode_image(encoded_image)
                return image
            return None
                    
        def get_image_format(self):
            image = self.get_image()
            return image.format if image else None
        
        def get_data_rLOD(self,lod=0):
            image = self.get_image()
            ratio = 10**(lod+1)
            if image.size[0]//ratio==0 or image.size[1]//ratio ==0:
                raise ValueError(f'img size({image.size}) of LOD{lod} is smaller than 0')
            return image.resize((image.size[0]//ratio,image.size[1]//ratio)) if image else None
      
        def get_data_rLOD0(self):
            return self.get_data_rLOD(lod=0)
        
        def get_data_rLOD1(self):
            return self.get_data_rLOD(lod=1)
        
        def get_data_rLOD2(self):
            return self.get_data_rLOD(lod=2)
        
      class AbstractObj(BaseModel):
        id: str
        rank: list = [0]
        create_time: datetime = Field(default_factory=get_current_datetime_with_utc)
        update_time: datetime = Field(default_factory=get_current_datetime_with_utc)
        status: str = ""
        metadata: dict = {}
        controller: AbstractObjController = None
        class Config:
          arbitrary_types_allowed=True
      class CommonData(AbstractObj):
        raw: str = ''
        rLOD0: str = ''
        rLOD1: str = ''
        rLOD2: str = ''
        controller: CommonDataController = None
      class Author(AbstractObj):
        id: str = Field(default_factory=lambda :f"Author:{uuid4()}")
        name: str = ''
        role: str = ''
        controller: AuthorController = None
      class AbstractContent(AbstractObj):
        author_id: str=''
        group_id: str=''
        controller: AbstractContentController = None
      
        def data_id(self):
            return f"CommonData:{self.id}"
      class AbstractGroup(AbstractObj):
        author_id: str=''
        parent_id: str = ''
        children_id: List[str] = []
        controller: AbstractGroupController = None
      class ContentGroup(AbstractGroup):
        id: str = Field(default_factory=lambda :f"ContentGroup:{uuid4()}")
        controller: ContentGroupController = None
      class TextContent(AbstractContent):
        id: str = Field(default_factory=lambda :f"TextContent:{uuid4()}")
        controller: TextContentController = None
      
      class EmbeddingContent(AbstractContent):
        id: str = Field(default_factory=lambda :f"EmbeddingContent:{uuid4()}")
        controller: EmbeddingContentController = None
        target_id: str
      class FileLinkContent(AbstractContent):
        id: str = Field(default_factory=lambda :f"FileLinkContent:{uuid4()}")
        controller: FileLinkContentController = None
      class BinaryFileContent(AbstractContent):
        id: str = Field(default_factory=lambda :f"BinaryFileContent:{uuid4()}")
        controller: BinaryFileContentController = None
            
      class ImageContent(BinaryFileContent):
        id: str = Field(default_factory=lambda :f"ImageContent:{uuid4()}")
        controller: ImageContentController = None
      
      class LLMstore(SingletonKeyValueStorage):
        client = SingletonKeyValueStorage().python_backend()
      
        def _client(self):
            return self.client
        
        def _get_all_object_names(self):
            return ['AbstractObj',
                    'CommonData',
                    'Author',
                    'AbstractContent',
                    'AbstractGroup',
                    'ContentGroup',
                    'TextContent',
                    'EmbeddingContent',
                    'FileLinkContent',
                    'BinaryFileContent',
                    'ImageContent',]
        
        def _get_all_object_classes(self):
            return [AbstractObj,
                    CommonData,
                    Author,
                    AbstractContent,
                    AbstractGroup,
                    ContentGroup,
                    TextContent,
                    EmbeddingContent,
                    FileLinkContent,
                    BinaryFileContent,
                    ImageContent,]    
        
        def _get_all_object_controller_classes(self):
            return [AbstractObjController,
                    CommonDataController,
                    AuthorController,
                    AbstractContentController,
                    AbstractGroupController,
                    ContentGroupController,
                    TextContentController,
                    EmbeddingContentController,
                    FileLinkContentController,
                    BinaryFileContentController,
                    ImageContentController,]
        
        def get_class(self, id: str):
            class_type = id.split(':')[0]
            res = {a:b for a,b in zip(self._get_all_object_names(),self._get_all_object_classes())}.get(class_type, None)
            if res is None:
                raise ValueError(f'No such class of {class_type}')
            return res
        
        def get_controller(self, id: str):
            class_type = id.split(':')[0]
            res = {a:b for a,b in zip(self._get_all_object_names(),self._get_all_object_controller_classes())}.get(class_type, None)
            if res is None:
                raise ValueError(f'No such controller of {class_type}')
            return res
       
        def _store_obj(self, obj:AbstractObj):
            d = json.loads(obj.json(exclude={'controller'}))
            self.client.set(obj.id,d)
            return obj
            
        def add_new_author(self,name, role, rank:list=[0], metadata={}) -> Author:
            auther = self._store_obj(Author(name=name, role=role, rank=rank, metadata=metadata))
            auther.controller = self.get_controller(auther.id)(self,auther)
            return auther
        
        def add_new_root_group(self,metadata={},rank=[0]) -> ContentGroup:
            group = self._store_obj( ContentGroup(rank=rank, metadata=metadata) )         
            group.controller = self.get_controller(group.id)(self,group)
            return group
        
        def _add_new_content_to_group(self,group:ContentGroup,content:AbstractContent,raw:str=None):
            group.children_id.append(content.id)
            self._store_obj(group)
            if raw is not None and 'ContentGroup' not in content.id:
                self._store_obj(content)
                self._store_obj(CommonData(id=content.data_id(), raw=raw))
            else:
                self._store_obj(content)
                
            content.controller = self.get_controller(content.id)(self,content)
            return group,content    
      
        def read_image(self, filepath):
            with open(filepath, "rb") as f:
                return f.read()
            
        def b64encode(self, file_bytes):
            return base64.b64encode(file_bytes)
            
        def encode_image(self, image_bytes):
            return self.b64encode(image_bytes)
        
        def add_new_group_to_group(self,group:ContentGroup,metadata={},rank=[0]):
            parent,child = self._add_new_content_to_group(group, ContentGroup(rank=rank, metadata=metadata, parent_id=group.id))
            return parent,child
      
        def add_new_text_to_group(self,group:ContentGroup,author_id:str,text:str):
            parent,child = self._add_new_content_to_group(group,
                                                          TextContent(author_id=author_id, group_id=group.id),
                                                          raw=text)
            return parent,child
        
        def add_new_embedding_to_group(self,group:ContentGroup, author_id:str, content_id:str, vec:list[float]):
            parent,child = self._add_new_content_to_group(group,
                                                          EmbeddingContent(author_id=author_id, 
                                                                           group_id=group.id,target_id=content_id),
                                                          raw=str(vec))
            return parent,child
        
        def add_new_image_to_group(self,group:ContentGroup,author_id:str, filepath:str):
            raw_bytes = self.read_image(filepath)
            raw_base64 = self.encode_image(raw_bytes)
            parent,child = self._add_new_content_to_group(group,
                                                          ImageContent(author_id=author_id,group_id=group.id),
                                                          raw=raw_base64)
            return parent,child
        
        # available for regx?
        def find(self,id:str) -> AbstractObj:
            data_dict = self.client.get(id)
            obj:AbstractObj = self.get_class(id)(**data_dict)
            obj.controller = self.get_controller(id)(self,obj)
            return obj
        
        def find_all(self,id:str=f'Author:*'):
            keys = [key for key in self.client.keys(id)]
            results:list[AbstractObj] = []
            for key in keys:
                obj = self.find(key)
                results.append(obj)
            return results
      
        def delete_obj(self, obj:AbstractObj):
            self.client.delete(obj.id)
            obj.controller = None
        
        def update_obj(self, obj:AbstractObj, **kwargs) -> AbstractObj:
            for k,v in kwargs.items():
                if v is not None and k in obj.model_fields:
                    obj.__dict__[k] = v
                    obj.update_time = get_current_datetime_with_utc()        
            self._store_obj(obj)
            return obj
      
      class Speaker:
        def __init__(self,author:Author) -> None:
            self.author = author
            self.id = self.author.id
            self.name = self.author.name#self.id[-8:]
            self.room:ChatRoom = None
            self.is_speaking = 0
            self.new_message_callbacks=[]
            self.mention_callbacks=[]
      
        def add_new_message_callback(self, cb):
            self.new_message_callbacks.append(cb)
            return self
      
        def add_mention_callback(self, cb):
            self.mention_callbacks.append(cb)
            return self
            
        def on_new_message(self, message:AbstractContent):
            for cb in self.new_message_callbacks:
                cb(self,message)
      
        def on_mention(self, message:AbstractContent):
            for cb in self.mention_callbacks:
                cb(self,message)
      
        def entery_room(self,room):
            self.room:ChatRoom = room
            self.room.add_speaker(self)
            rooms = self.author.metadata.get('groups','')
            if self.room.chatroom().id not in rooms:
                rooms += self.room.chatroom().id
                self.author.controller.update_metadata('groups',rooms)
            return self
        
        def new_group(self):
            if self.room is None:
                raise ValueError('please enter room at first')
            groupid = self.room.add_content_group_to_chatroom()        
            return groupid
      
        def speak_img(self,imgpath:str,group_id:str=None,new_group=False):
            self.is_speaking += 1
            if self.room is not None:
                self.room.speak_img(self.id,imgpath,group_id,new_group)
            self.is_speaking -= 1
            return self
      
        def speak(self,msg:str,group_id:str=None,new_group=False):
            self.is_speaking += 1
            if self.room is not None:
                self.room.speak(self.id,msg,group_id,new_group)
            self.is_speaking -= 1
            return self
        
        # def speak_stream(self,stream,group_id:str=None,new_group=False):
        #     self.is_speaking += 1
        #     def callback():
        #         self.is_speaking -= 1
        #     if self.room is not None:
        #         worker_thread = threading.Thread(target=self.room.speak_stream,args=(self.id,stream,callback,group_id,new_group))
        #         worker_thread.start()
        #     return self
            
      class ChatRoom:
          def __init__(self, store:LLMstore, chatroom_id:str=None, speakers:Dict[str,Speaker]={}) -> None:
              self.store=store
              self.speakers=speakers
              chatroom:ContentGroup = None
              roots:List[ContentGroup] = self.store.find_all('ContentGroup:*')
              if chatroom_id is None:
                  roots = [g for g in roots if len(g.parent_id)==0]
                  if len(roots)==0:
                      print(f'no group({chatroom_id}) in store, make a new one')
                      roots = [self.store.add_new_root_group()]
              else:
                  roots = [g for g in roots if g.id==chatroom_id]
                  if len(roots)==0:
                      raise ValueError(f'no group({chatroom_id}) in store')        
              chatroom = roots[0]  
              self.chatroom_id = chatroom.id
              self.msgs = []
              
              for a in self.store.find_all('Author:*'):
                  if self.chatroom_id in a.metadata.get('groups',''):
                      Speaker(a).entery_room(self)
          
          def chatroom(self):
              res:ContentGroup = self.store.find(self.chatroom_id)
              return res
      
          def _on_message_change(self):
              self.msgs = self.get_messages_in_group()
          
          def add_content_group_to_chatroom(self):
              gc:ContentGroupController = self.chatroom().controller
              child = gc.add_new_child_group()
              self._on_message_change()
              return child.id
          
          def get_messages_in_group(self,id=None)->List[AbstractContent]:
              if id is None:
                  gc:ContentGroupController = self.chatroom().controller
                  return gc.get_children_content()
              else:
                  gc:ContentGroupController = self.store.find(id).controller
                  return gc.get_children_content()
          
          def get_messages_recursive_in_chatroom(self):
              gc:ContentGroupController = self.chatroom().controller
              return gc.get_children_content_recursive()
          
          def traverse_nested_messages(self, nested_content_list=None):
              if nested_content_list is None:nested_content_list=self.get_messages_recursive_in_chatroom()
              for element in nested_content_list:
                  if isinstance(element, list):
                      for e in self.traverse_nested_messages(element):
                          yield e
                  else:
                      yield element
          
          ##################################################################
      
          def add_speaker(self,speaker:Speaker):
              self.speakers[speaker.id] = speaker
              self.speakers[speaker.name] = speaker
      
          def get_speaker(self,speaker_id) -> Speaker:
              if speaker_id not in self.speakers:
                  raise ValueError(f'no such user {speaker_id}')
              return self.speakers[speaker_id]
      
          def get_mentions(self, message:AbstractContent, speaker_ids=[]):
              msg_auther = self.speakers[message.author_id].name
              mentions = re.findall(r'@([a-zA-Z0-9]+)', message.controller.get_data_raw())
              targets = []
              
              for mention in mentions:
                  for speaker in {self.get_speaker(s) for s in speaker_ids}:                
                      if speaker.name == mention and msg_auther!=mention:
                          targets.append(speaker.id)
              return targets
          
          def notify_new_message(self, message:AbstractContent, speaker_ids=[]):
              speaker_ids = set(speaker_ids)-set(self.get_mentions(message,speaker_ids))-set(self.speakers[message.author_id].id)
              ids = list(set([self.speakers[s] for s in speaker_ids]))
              ids = sorted(ids, key=lambda x:x.author.rank[0])
              for speaker in ids:
                  speaker.on_new_message(message)
          
          def notify_mention(self, message:AbstractContent, speaker_ids=[]):
              speaker_ids = self.get_mentions(message, speaker_ids)
              ids = list(set([self.speakers[s] for s in speaker_ids]))
              ids = sorted(ids, key=lambda x:x.author.rank[0])
              for speaker in ids:
                  speaker.on_mention(message)
          
          def _prepare_speak(self,speaker_id,group_id:str=None,new_group=False,type='Text',msg=''):
              speaker = self.get_speaker(speaker_id)
      
              def add_content(obj:ContentGroup,type=type):
                  if 'Text' in type:
                      return obj.controller.add_new_text_content
                  elif 'Image' in type:
                      return obj.controller.add_new_image_content
                  else:
                      raise ValueError(f'Unknown type of {type}')
      
              if (group_id is None and not new_group) or (group_id == self.chatroom_id):
                  tc = add_content(self.chatroom())
      
              elif group_id is not None and not new_group:
                  if group_id not in self.chatroom().children_id:
                      raise ValueError(f'no such group {group_id}')
                  group:ContentGroup = self.store.find(group_id)
                  tc = add_content(group)
                  self._on_message_change()
      
              elif group_id is None and new_group:            
                  controller:ContentGroupController = self.chatroom().controller
                  group = controller.add_new_child_group()
                  tc = add_content(group)
              return tc(speaker.author.id, msg)
      
          # def speak_stream(self,speaker_id,stream,callback,group_id:str=None,new_group=False):
          #     content:TextContent = None#self._prepare_speak(speaker_id,group_id,new_group)
          #     msg = ''
          #     for i,r in enumerate(stream):
          #         if r and i==0:
          #             content = self._prepare_speak(speaker_id,group_id,new_group)
          #         assert r is not None, f'can not prepare string reply in speak_stream! {r}'
          #         content.append_data_raw(r)
          #         msg += r
          #     callback()
          #     self.notify_new_message(content, self.speakers.keys())
          #     self.notify_mention(content, self.speakers.keys())
      
          def speak(self,speaker_id,msg:str,group_id:str=None,new_group=False):
              content = self._prepare_speak(speaker_id,group_id,new_group,msg=msg)
              self.notify_new_message(content, self.speakers.keys())
              self.notify_mention(content, self.speakers.keys())
              return content
          
          def speak_img(self,speaker_id,imagpath:str,group_id:str=None,new_group=False):
              content = self._prepare_speak(speaker_id,group_id,new_group,type='Image',msg=imagpath)
              self.notify_new_message(content, self.speakers.keys())
              self.notify_mention(content, self.speakers.keys())
              return content
          #######################################################################
      
          def msgsDict(self,refresh=False,msgs=None,todict=None):        
              if todict is None:
                  def todict(v:AbstractContent):
                      c:AbstractContentController = v.controller
                      n = v.__class__.__name__
                      if 'Text' in n:
                          return {"type": "text","text": c.get_data_raw()}
                      if 'Image' in n:
                          return {"type": "image_url","image_url": {
                                      "url": f"data:image/jpeg;base64,{c.get_data_raw()}"}}                
                  # todict = lambda c:c.load().get_data_raw()
                  
              if refresh:
                  self.msgs:List[AbstractContent] = self.get_messages_in_group()
              if msgs is None:
                  msgs = self.msgs
      
              res = []
              for v in msgs:
                  if 'ContentGroup' not in v.__class__.__name__:
                      mc:AbstractContentController = v.controller
                      name = mc.get_author().name
                      role = mc.get_author().role
                      if 'EmbeddingContent' in v.__class__.__name__:
                          ec:EmbeddingContentController = v.controller
                          mc:AbstractContentController = ec.get_target().controller
                          t = mc.get_data_raw()[:10]
                          # print(f'{intents}{self.speakers[m.model.author_id].name}: "{t}"=>{m.load().get_data_raw()[:5]}...')
                      elif 'TextContent' in v.__class__.__name__:
                          res.append(dict(name=name,role=role,content=todict(v)))
                      else:
                          res.append(dict(name=name,role=role,content=todict(v)))
                  else:
                      res.append(self.msgsDict(False,self.get_messages_in_group(v.id)))
              return res
      
      
          def printMsgs(self,refresh=False,intent=0,msgs:List[AbstractContent]=None):
              if refresh:
                  self.msgs:List[AbstractContent] = self.get_messages_in_group()
              if msgs is None:
                  msgs = self.msgs
              intents = "".join([' ']*intent)
              print("", flush=True)
              print(f'{intents}#############################################################')
              
              for i,v in enumerate(msgs):
                  print(f'{intents}-------------------------------------------------------------')
                  if 'ContentGroup' not in v.__class__.__name__:
                      if 'EmbeddingContent' in v.__class__.__name__:
                          econtroller:EmbeddingContentController = v.controller
                          tcontroller:AbstractContentController = econtroller.get_target().controller
                          t = tcontroller.get_data_raw()[:10]
                          print(f'{intents}{self.speakers[econtroller.get_target().author_id].name}: "{t}"=>{econtroller.get_data_raw()[:5]}...')
                      elif 'ImageContent' in v.__class__.__name__:
                          vcontroller:ImageContentController = v.controller
                          im = vcontroller.get_image()
                          print(f'{intents}{self.speakers[v.author_id].name}: Image{im.size} of {im.info}')
                      else:
                          vcontroller:AbstractContentController = v.controller
                          print(f'{intents}{self.speakers[v.author_id].name}: {vcontroller.get_data_raw()}')
                  else:
                      self.printMsgs(False,intent+4,self.get_messages_in_group(v.id))
              print(f'{intents}-------------------------------------------------------------')
              print(f'{intents}#############################################################')

      import threading
      from typing import List
      class Configs:
          class Config:
              def __init__(self, name, value) -> None:
                  self.name = name
                  self.value = value
                  self.lock = threading.Lock()
      
              def update(self, value):
                  with self.lock:
                      self.value = value
                      return value
              
              def get(self):
                  with self.lock:
                      return self.value
              
          def __init__(self) -> None:
              self._configs = {}
              self.configs_lock = threading.Lock()
      
          def tolist(self):
              with self.configs_lock:
                  return list(self._configs.values())
          
          def new_config(self, name, value):
              with self.configs_lock:
                  if name in self._configs:
                      raise Exception("Config with this name already exists.")
                  tmp = Configs.Config(name, value)
                  self._configs[name] = tmp
                  return tmp
      
          def get(self, name):
              with self.configs_lock:
                  return self._configs[name]
          
          def delete(self, name):
              with self.configs_lock:
                  if name in self._configs:
                      del self._configs[name]
                  else:
                      raise KeyError(f"No configuration with the name '{name}' exists.")
      
      try:
          import gradio as gr     
          def build_gui(cr:ChatRoom,configs:List[Configs.Config]=[],json=None):
              def roomdelmsg(msgid,cr:ChatRoom=cr):
                  try:
                      if str(msgid).isdecimal() and int(msgid)>0:
                          for m in cr.chatroom().controller.get_children_content()[-int(msgid):]:
                              cr.chatroom().controller.remove_child(m.id)
                          cr.store.dump(json)
                          return True,chat(None,'')
                      
                      for msgid in msgid.split('\n'):
                          cr.chatroom().controller.remove_child(msgid)
                      cr.store.dump(json)
                      
                      return True,chat(None,'')
                  except Exception as e:
                      return f'{e}',chat(None,'')
              
              def clonemsg(msgid,cr:ChatRoom=cr):
                  try:
                      for msgid in msgid.split('\n'):
                          gc:ContentGroupController = cr.chatroom().controller
                          c = gc.get_child_content(msgid)
                          if type(c) is TextContent:
                              text = c.controller.get_data_raw()
                              return chat(c.controller.get_author().id,c.controller.get_data_raw())
                  except Exception as e:
                      return f'{e}'
                  
              def chat(author_id:str=None, message:str=None,filepath:str=None, cr:ChatRoom=cr,configs:List[Configs.Config]=configs):
                  try:                
                      if message is None:
                          return f'# Welcome to {json}, show messages by "Reflesh"'
                      if len(message)>0 and author_id in cr.speakers and filepath:
                          s = cr.speakers[author_id]
                          gid = s.new_group()
                          s.speak_img(filepath,gid)
                          s.speak(message,gid)
                          
                      elif len(message)>0 and author_id in cr.speakers:
                          cr.speakers[author_id].speak(message)
      
                      show_passages = [c for c in configs if c.name=='show_passages']
                      show_passages = int(show_passages[0].value) if len(show_passages)>0 else 10
                      
                      def get_msgs_md(msgs:List[AbstractContent],cr:ChatRoom=cr,depth=0):
                          res = []
                          for i,v in enumerate(msgs):
                              if 'ContentGroup' not in v.__class__.__name__:
                                  if 'EmbeddingContent' in v.__class__.__name__:
                                      econtroller:EmbeddingContentController = v.controller
                                      tcontroller:AbstractContentController = econtroller.get_target().controller
                                      t = tcontroller.get_data_raw()[:10]
      
                                      name = cr.speakers[econtroller.get_target().author_id].name
                                      msg = f'"{t}"=>{econtroller.get_data_raw()[:5]}...'
      
                                  elif 'ImageContent' in v.__class__.__name__:
                                      vcontroller:ImageContentController = v.controller
                                      im = vcontroller.get_image()
                                      imid = v.id.split(':')[1]
                                      b64 = vcontroller.get_data_raw()
                                      im = vcontroller.get_image()
                                      
                                      name = cr.speakers[v.author_id].name
                                      msg = f'![{imid}](data:image/{im.format};base64,{b64})'
                                  else:
                                      vcontroller:AbstractContentController = v.controller
                                      
                                      name = cr.speakers[v.author_id].name
                                      msg = vcontroller.get_data_raw().replace("\n","\n>\n>")
      
                                  m = f'\n\n##### {name}:\n>{msg}\n>\n>_{v.create_time} {v.id}_'
                                  if depth>0:
                                      lvl = ''.join(['>']*(depth+1))
                                      m = m.replace('>',lvl)
                                      lvl = ''.join(['>']*(depth))
                                      m = m.replace('#####',f'{lvl}#####')
                                  res.append(m)
                              else:
                                  res.append("\n".join(get_msgs_md(cr.get_messages_in_group(v.id),depth=depth+1)))
                          return res
                      return "\n".join(get_msgs_md(cr.get_messages_in_group()[-show_passages:]))
                  except Exception as e:
                      return f'{e}'
      
              with gr.Blocks() as demo:
                  with gr.Tab("Chat"):
                      with gr.Column():
                          with gr.Row():
                              msgid = gr.Textbox(label="Message Id")
                              delmsg =gr.Button("Delete")
                              clmsg =gr.Button("Clone")
                              reflesh = gr.Button("Reflesh")
                              
      
                          # history = gr.Textbox(label="History",value=chat(None,None))                
                          history = gr.Markdown(label="History",value=chat(None,None))
                          author = gr.Dropdown(value='User',choices=[n for n in cr.speakers.keys() if ':' not in n], label="Author")
                          
                          with gr.Tab("Text"):
                              message = gr.Textbox(label="Message")
                          with gr.Tab("Image"):
                              image_file = gr.Image(type='filepath')
                          send = gr.Button("Send")                    
                          
                          clmsg.click(fn=clonemsg, inputs=[msgid], outputs=history)
                          reflesh.click(fn=lambda :chat(None,''), inputs=[], outputs=history)
                          send.click(fn=chat, inputs=[author,message,image_file], outputs=history)
                          delmsg.click(fn=roomdelmsg, inputs=[msgid], outputs=[msgid,history])
      
                          # image_button_filepath.click(save_image_filepath, inputs=image_input_filepath)
      
                  with gr.Tab("Config"):
                      with gr.Column():
                          for i,c in enumerate(configs):                    
                              with gr.Row():
                                  config_value = gr.Textbox(label=c.name, value=c.value)
                                  getv = gr.Button("Get")
                                  update = gr.Button("Update")
                                  update.click(fn=c.update, inputs=[config_value], outputs=[config_value])
                                  getv.click(fn=c.get, inputs=[], outputs=[config_value])
      
                      # demo.launch()
                      # demo.launch(auth=("admin", "admin"))
              return demo
      except Exception as e:
          print(e)

                    
      sss = LLMstore()
      cr = ChatRoom(sss)
      
      configs = Configs()
      model=configs.new_config('model','gpt-4o')
      num_passages=configs.new_config('num passages','1')
      OPENAI_API_KEY=configs.new_config('openai api key',os.environ.get('OPENAI_API_KEY','null'))

      def openairequest(url,jsonstr):
          headers = {"Authorization": f"Bearer {OPENAI_API_KEY.value}","Content-Type": "application/json"}
          data = jsonstr
          response = requests.post(url=url, data=data, headers=headers)
          try:
              response = json.loads(response.text,strict=False)
          except Exception as e:
              if type(response) is not dict:
                  return {'error':f'{e}'}
              else:
                  return {'error':f'{response}({e})'}
          return response

      def openaimsg():
          msgd = cr.msgsDict(True,todict = lambda c:c.controller.get_data_raw())
          def mergelist(l):
              name,role = l[0]['name'],l[0]['role']        
              return dict(name=name,role=role,content=[c['content'] for c in l])
          messages = [(d if type(d) is not list else mergelist(d)) for d in msgd]
          return messages

      def pygpt(speaker:Speaker, msg:AbstractContent):
          data = {"model": model.value,
                  "messages": [{"role":"system",
                              "content":"Your name is VisionMaster and good at making description of image."}] + openaimsg()[-int(num_passages.value):]}
          response = openairequest(url="https://api.openai.com/v1/chat/completions",jsonstr=json.dumps(data,ensure_ascii=False))
          speaker.speak(str(response['error']) if 'error' in response else response['choices'][0]['message']['content'])

      cr.speakers.get('VisionMaster',Speaker(cr.store.add_new_author(name="VisionMaster",role="assistant",metadata={'model':model.value}))
                                      ).entery_room(cr).add_mention_callback(pygpt)

      u = cr.speakers.get('User',Speaker(cr.store.add_new_author(name="User", role="user"))).entery_room(cr)

      build_gui(cr,configs.tolist(),'visionRoom.json').launch()
    </gradio-lite>
  </body>
</html>
